# Возврат результата (get-step)

Для этого используются наследники `ru.tinkoff.qa.neptune.core.api.steps.SequentialGetStepSupplier`. 

Ниже пример, демонстрирующий работу и принцип данного класса. 

```java
package org.my.pack;

import java.time.Duration;
import java.util.function.Function;

import ru.tinkoff.qa.neptune.core.api.steps.SequentialGetStepSupplier;
import ru.tinkoff.qa.neptune.core.api.steps.FunctionFactory;

public class MyGetStepSupplier<T, M, P>
        extends SequentialGetStepSupplier<MyTestContext, T, M, P,
        //Здесь нужно указывать тип самого класса или расширяющий тип
        MyGetStepSupplier<T, M, P>> 
        //Наследники SequentialGetStepSupplier работают как Builder, и многие методы
        //возвращают ссылку на объект, от которого ини были вызваны
{


    protected <S> SequentialGetStepSupplier(
        Function<M, S> stepFunction, //Функция описывает то, 
        // что шаг выполняет непосредственно         
        FunctionFactory<M, S, T, P> functionFactory, //Класс, 
        //реализующий данный интерфейс: 
        // - описывает, как объект S превращается в объект T
        //---------------------------------------------------
        // - описывает алгоритм работы таймаута ожидания результата, который
        // должен соответствовать переданным критериям
        //---------------------------------------------------
        // - описывает алгоритм проверки значения T на соответствие
        // переданным критериям. Проверять на соответствие критериям можно: 
        //      сам объект T, если P и T - один и тот же тип
        //      каждый элемент массива, если T - это массив элементов P
        //      каждый элемент коллекции, если T - это коллекция элементов P
        //      какую-то производную величину от T, например объект P возвращается
        //      get* методом объекта T.
        //Описанные выше нюансы зависят от дизайна и назначения шага
        //---------------------------------------------------
        // - описывает, какие исключения следует игнорировать в ходе 
        // выполнения шага
        //---------------------------------------------------
        // - описывает какие исключения должны быть выброшены, если 
        // за отведенное время шаг вернул пустой результат (пустым результатом 
        // можно считать null, пустой массив или пустую коллекцию, в зависимости от 
        // дизайна шага и его назначения)
        //---------------------------------------------------
        Object a, //опционально
        Object b,  //параметры шага
        Object c
    ) {
        super(stepFunction, functionFactory);
    }
    
    public static <T, M, P> MyGetStepSupplier<T, M, P> something(
            Object a,
            Object b,
            Object c) {
        return new MyGetStepSupplier<>(/*параметры конструктора*/);
    }

    //Добавлено для наглядности
    //В большинстве случаев данный метод перекрывать не требуется
    @Override //Результирующая функция-шаг возвращается данным методом.
    public Function<MyTestContext, T> get() {
      return super.get();
    }    

    //Если конечный результат, соответствующий критериям, может быть
    //возвращен не сразу, то следует предусмотреть возможность
    //указывать приемлемый интервал времени, за который этот результат
    //должен быть получен.
    @Override
    public MyGetStepSupplier<T, M, P> timeOut(Duration timeOut) {
        return super.timeOut(timeOut);
    }

    //Если между попытками получить необходимый результат нужно делать паузу
    //(в рамках отведенного времени), то надо иметь возможность
    //указывать продолжительность этой паузы. Как в примере ниже.
    @Override
    public MyGetStepSupplier<T, M, P> pollingInterval(Duration pollingTime) {
        return super.pollingInterval(pollingTime);
    }

    // Здесь можно описать действия, что выполнятся до начала шага.
    // По умолчанию данный метод пустой, но не абстрактный, т.к. в большинстве случаев
    // никаких дополнительных действий выполнять не нужно.
    @Override
    protected void onStart(M m) {
        //Какая-то логика
    }

    // Здесь можно описать действия, выполняемые после того, как результат был вычислен.
    // По умолчанию данный метод пустой, но не абстрактный, т.к. в большинстве случаев
    // никаких дополнительных действий выполнять не нужно.
    @Override
    protected void onSuccess(T t) {
        //Какая-то логика
    }

    // Здесь можно описать действия, выполняемые после того, как было выброшено
    // исключение, которое либо не удалось проигнорировать в процессе вычисления,
    // либо было выброшено потому, что выполнение шага не дало ожидаемого результата.
    // По умолчанию данный метод пустой, но не абстрактный, т.к. в большинстве случаев
    // никаких дополнительных действий выполнять не нужно.
    @Override
    protected void onFailure(M m, Throwable throwable) {
        //Какая-то логика
    }

    // Здесь описывается Map<String, String>, 
    // в котором ключ - название параметра, значение - значение параметра.
    // Не всегда параметры можно передать до начала выполнения шага. 
    // Некоторые значения могут получиться в процессе 
    // выполнения шага.
    @Override
    protected Map<String, String> additionalParameters() {
        //Возврат дополнительных динамических параметров, которые 
        // были рассчитаны уже в процессе выполнения шага
    }
}
```

Небольшое пояснение к примеру:

- данный класс строит шаг, работающий по принципу функции (`java.util.function.Function`)

- входным значением является объект-[контекст](../../context/index.md), содержащий нужные ресурсы для выполнения.
  выходным - значение типа `T`

- выходное значение `T` может быть получено прямым вычислением с использованием входного

- так же выходное значение `T` может быт получено через цепочку промежуточных вычислений, в которой [контекст](../../context/index.md) 
  является входным параметром для всей цепочки (иерархической последовательности шагов). Значение типа `M` является аргументом
  для вычисления `T` и выходным значением предшествующей цепочки / последовательности шагов

- результат `T` должен соответствовать некоторым критериям, которые проверяют результат по значению
  типа `P`.

Данный пример демонстрирует принцип работы. В большинстве случаев рекомендуется воспользоваться одним из
классов — наследников `ru.tinkoff.qa.neptune.core.api.steps.SequentialGetStepSupplier` согласно одной из часто
встречающихся ситуаций:


```{toctree}

get_object_step.md
get_object_from_iterable_step.md
get_object_from_array_step.md
get_list_step.md
get_array_step.md
```