# Возврат результата (get-step)

Для этого используются наследники `ru.tinkoff.qa.neptune.core.api.steps.SequentialGetStepSupplier`.

Ниже пример, демонстрирующий работу и принцип данного класса.

```java
package org.my.pack;

import ru.tinkoff.qa.neptune.core.api.steps.SequentialGetStepSupplier;

import java.time.Duration;
import java.util.function.Function;

public class MyGetStepSupplier<T, M, P>
        extends SequentialGetStepSupplier<MyTestContext, T, M, P,
        //Здесь нужно указывать тип самого класса или расширяющий тип
        MyGetStepSupplier<T, M, P>> 
        //Наследники SequentialGetStepSupplier работают как Builder, и многие методы
        //возвращают ссылку на объект, от которого ини были вызваны
{
    
    public static <T, M, P> MyGetStepSupplier<T, M, P> something(
            Object a, //опционально
            Object b,  //параметры шага
            Object c) {
        //возвращает объект шага
        return new MyGetStepSupplier<>(/*параметры конструктора*/);
    }

    //Добавлено для наглядности
    //В большинстве случаев данный метод наследовать/перекрывать не требуется
    @Override
    protected Function<M, T> getEndFunction() {
      return //формирование функции-шага
    }

    //Добавлено для наглядности
    //В большинстве случаев данный метод перекрывать не требуется
    @Override //Результирующая функция-шаг возвращается данным методом.
    public Function<MyTestContext, T> get() {
      return super.get();
    }    

    //Если конечный результат, соответствующий критериям, может быть
    //возвращен не сразу, то следует предусмотреть возможность
    //указывать приемлемый интервал времени, за который этот результат
    //должен быть получен.
    @Override
    public MyGetStepSupplier<T, M, P> timeOut(Duration timeOut) {
        return super.timeOut(timeOut);
    }

    //Если между попытками получить необходимый результат нужно делать паузу
    //(в рамках отведенного времени), то надо иметь возможность
    //указывать продолжительность этой паузы. Как в примере ниже.
    @Override
    public MyGetStepSupplier<T, M, P> pollingInterval(Duration pollingTime) {
        return super.pollingInterval(pollingTime);
    }

    // Здесь можно описать действия, что выполнятся до начала шага.
    // По умолчанию данный метод пустой, но не абстрактный, т.к. в большинстве случаев
    // никаких дополнительных действий выполнять не нужно.
    @Override
    protected void onStart(M m) {
        //Какая-то логика
    }

    // Здесь можно описать действия, выполняемые после того, как результат был вычислен.
    // По умолчанию данный метод пустой, но не абстрактный, т.к. в большинстве случаев
    // никаких дополнительных действий выполнять не нужно.
    @Override
    protected void onSuccess(T t) {
        //Какая-то логика
    }

    // Здесь можно описать действия, выполняемые после того, как было выброшено
    // исключение, которое либо не удалось проигнорировать в процессе вычисления,
    // либо было выброшено потому, что выполнение шага не дало ожидаемого результата.
    // По умолчанию данный метод пустой, но не абстрактный, т.к. в большинстве случаев
    // никаких дополнительных действий выполнять не нужно.
    @Override
    protected void onFailure(M m, Throwable throwable) {
        //Какая-то логика
    }

    // Здесь описывается Map<String, String>, 
    // в котором ключ - название параметра, значение - значение параметра.
    // Не всегда параметры можно передать до начала выполнения шага. 
    // Некоторые значения могут получиться в процессе 
    // выполнения шага.
    @Override
    protected Map<String, String> additionalParameters() {
        //Возврат дополнительных динамических параметров, которые 
        // были рассчитаны уже в процессе выполнения шага
    }
}
```

Небольшое пояснение к примеру:

- данный класс строит шаг, работающий по принципу функции (`java.util.function.Function`)

- входным значением является объект-[контекст](../../context/index.md), содержащий нужные ресурсы для выполнения.
  выходным - значение типа `T`

- выходное значение `T` может быть получено прямым вычислением с использованием входного

- так же выходное значение `T` может быт получено через цепочку промежуточных вычислений, в
  которой [контекст](../../context/index.md)
  является входным параметром для всей цепочки (иерархической последовательности шагов). Значение типа `M` является
  аргументом для вычисления `T` и выходным значением предшествующей цепочки / последовательности шагов

- результат `T` должен соответствовать некоторым критериям, которые проверяют результат по значению типа `P`. В
  зависимости от типа шага это может быть значение `T`, или тип значения элемента результирующего листа или массива

Данный пример демонстрирует принцип работы. В большинстве случаев рекомендуется воспользоваться одним из классов —
наследников `ru.tinkoff.qa.neptune.core.api.steps.SequentialGetStepSupplier` согласно одной из часто встречающихся
ситуаций:

```{toctree}

get_object_step.md
get_object_from_iterable_step.md
get_object_from_array_step.md
get_list_step.md
get_array_step.md
```